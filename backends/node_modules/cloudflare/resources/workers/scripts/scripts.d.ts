import * as Core from "../../../core.js";
import { APIResource } from "../../../resource.js";
import { type Response } from "../../../_shims/index.js";
import * as ScriptsAPI from "./scripts.js";
import * as WorkersAPI from "../workers.js";
import * as ContentAPI from "./content.js";
import * as DeploymentsAPI from "./deployments.js";
import * as SchedulesAPI from "./schedules.js";
import * as SettingsAPI from "./settings.js";
import * as TailAPI from "./tail.js";
import * as VersionsAPI from "./versions.js";
import { type Uploadable } from "../../../core.js";
import { SinglePage } from "../../../pagination.js";
export declare class Scripts extends APIResource {
    schedules: SchedulesAPI.Schedules;
    tail: TailAPI.Tail;
    content: ContentAPI.Content;
    settings: SettingsAPI.Settings;
    deployments: DeploymentsAPI.Deployments;
    versions: VersionsAPI.Versions;
    /**
     * Upload a worker module.
     */
    update(scriptName: string, params: ScriptUpdateParams, options?: Core.RequestOptions): Core.APIPromise<Script>;
    /**
     * Fetch a list of uploaded workers.
     */
    list(params: ScriptListParams, options?: Core.RequestOptions): Core.PagePromise<ScriptsSinglePage, Script>;
    /**
     * Delete your worker. This call has no response body on a successful delete.
     */
    delete(scriptName: string, params: ScriptDeleteParams, options?: Core.RequestOptions): Core.APIPromise<void>;
    /**
     * Fetch raw script content for your worker. Note this is the original script
     * content, not JSON encoded.
     */
    get(scriptName: string, params: ScriptGetParams, options?: Core.RequestOptions): Core.APIPromise<Response>;
}
export declare class ScriptsSinglePage extends SinglePage<Script> {
}
export interface Script {
    /**
     * The id of the script in the Workers system. Usually the script name.
     */
    id?: string;
    /**
     * When the script was created.
     */
    created_on?: string;
    /**
     * Hashed script content, can be used in a If-None-Match header when updating.
     */
    etag?: string;
    /**
     * Whether Logpush is turned on for the Worker.
     */
    logpush?: boolean;
    /**
     * When the script was last modified.
     */
    modified_on?: string;
    /**
     * Specifies the placement mode for the Worker (e.g. 'smart').
     */
    placement_mode?: string;
    /**
     * List of Workers that will consume logs from the attached Worker.
     */
    tail_consumers?: Array<TailAPI.ConsumerScript>;
    /**
     * Specifies the usage model for the Worker (e.g. 'bundled' or 'unbound').
     */
    usage_model?: string;
}
export interface ScriptSetting {
    /**
     * Whether Logpush is turned on for the Worker.
     */
    logpush?: boolean;
    /**
     * List of Workers that will consume logs from the attached Worker.
     */
    tail_consumers?: Array<TailAPI.ConsumerScript>;
}
export type ScriptUpdateParams = ScriptUpdateParams.Variant0 | ScriptUpdateParams.Variant1;
export declare namespace ScriptUpdateParams {
    interface Variant0 {
        /**
         * Path param: Identifier
         */
        account_id: string;
        /**
         * Query param: Rollback to provided deployment based on deployment ID. Request
         * body will only parse a "message" part. You can learn more about deployments
         * [here](https://developers.cloudflare.com/workers/platform/deployments/).
         */
        rollback_to?: string;
        /**
         * Body param: A module comprising a Worker script, often a javascript file.
         * Multiple modules may be provided as separate named parts, but at least one
         * module must be present and referenced in the metadata as `main_module` or
         * `body_part` by part name. Source maps may also be included using the
         * `application/source-map` content type.
         */
        '<any part name>'?: Array<Uploadable>;
        /**
         * Body param: JSON encoded metadata about the uploaded parts and Worker
         * configuration.
         */
        metadata?: ScriptUpdateParams.Variant0.Metadata;
    }
    namespace Variant0 {
        /**
         * JSON encoded metadata about the uploaded parts and Worker configuration.
         */
        interface Metadata {
            /**
             * List of bindings available to the worker.
             */
            bindings?: Array<unknown>;
            /**
             * Name of the part in the multipart request that contains the script (e.g. the
             * file adding a listener to the `fetch` event). Indicates a
             * `service worker syntax` Worker.
             */
            body_part?: string;
            /**
             * Date indicating targeted support in the Workers runtime. Backwards incompatible
             * fixes to the runtime following this date will not affect this Worker.
             */
            compatibility_date?: string;
            /**
             * Flags that enable or disable certain features in the Workers runtime. Used to
             * enable upcoming features or opt in or out of specific changes not included in a
             * `compatibility_date`.
             */
            compatibility_flags?: Array<string>;
            /**
             * List of binding types to keep from previous_upload.
             */
            keep_bindings?: Array<string>;
            /**
             * Whether Logpush is turned on for the Worker.
             */
            logpush?: boolean;
            /**
             * Name of the part in the multipart request that contains the main module (e.g.
             * the file exporting a `fetch` handler). Indicates a `module syntax` Worker.
             */
            main_module?: string;
            /**
             * Migrations to apply for Durable Objects associated with this Worker.
             */
            migrations?: WorkersAPI.SingleStepMigrationParam | WorkersAPI.SteppedMigrationParam;
            placement?: WorkersAPI.PlacementConfigurationParam;
            /**
             * List of strings to use as tags for this Worker
             */
            tags?: Array<string>;
            /**
             * List of Workers that will consume logs from the attached Worker.
             */
            tail_consumers?: Array<TailAPI.ConsumerScriptParam>;
            /**
             * Usage model to apply to invocations.
             */
            usage_model?: 'bundled' | 'unbound';
            /**
             * Key-value pairs to use as tags for this version of this Worker
             */
            version_tags?: unknown;
        }
    }
    interface Variant1 {
        /**
         * Path param: Identifier
         */
        account_id: string;
        /**
         * Query param: Rollback to provided deployment based on deployment ID. Request
         * body will only parse a "message" part. You can learn more about deployments
         * [here](https://developers.cloudflare.com/workers/platform/deployments/).
         */
        rollback_to?: string;
        /**
         * Body param: Rollback message to be associated with this deployment. Only parsed
         * when query param `"rollback_to"` is present.
         */
        message?: string;
    }
}
export interface ScriptListParams {
    /**
     * Identifier
     */
    account_id: string;
}
export interface ScriptDeleteParams {
    /**
     * Path param: Identifier
     */
    account_id: string;
    /**
     * Query param: If set to true, delete will not be stopped by associated service
     * binding, durable object, or other binding. Any of these associated
     * bindings/durable objects will be deleted along with the script.
     */
    force?: boolean;
}
export interface ScriptGetParams {
    /**
     * Identifier
     */
    account_id: string;
}
export declare namespace Scripts {
    export import Script = ScriptsAPI.Script;
    export import ScriptSetting = ScriptsAPI.ScriptSetting;
    export import ScriptsSinglePage = ScriptsAPI.ScriptsSinglePage;
    export import ScriptUpdateParams = ScriptsAPI.ScriptUpdateParams;
    export import ScriptListParams = ScriptsAPI.ScriptListParams;
    export import ScriptDeleteParams = ScriptsAPI.ScriptDeleteParams;
    export import ScriptGetParams = ScriptsAPI.ScriptGetParams;
    export import Schedules = SchedulesAPI.Schedules;
    export import Schedule = SchedulesAPI.Schedule;
    export import ScheduleUpdateResponse = SchedulesAPI.ScheduleUpdateResponse;
    export import ScheduleGetResponse = SchedulesAPI.ScheduleGetResponse;
    export import ScheduleUpdateParams = SchedulesAPI.ScheduleUpdateParams;
    export import ScheduleGetParams = SchedulesAPI.ScheduleGetParams;
    export import Tail = TailAPI.Tail;
    export import ConsumerScript = TailAPI.ConsumerScript;
    export import TailCreateResponse = TailAPI.TailCreateResponse;
    export import TailDeleteResponse = TailAPI.TailDeleteResponse;
    export import TailGetResponse = TailAPI.TailGetResponse;
    export import TailCreateParams = TailAPI.TailCreateParams;
    export import TailDeleteParams = TailAPI.TailDeleteParams;
    export import TailGetParams = TailAPI.TailGetParams;
    export import Content = ContentAPI.Content;
    export import ContentUpdateParams = ContentAPI.ContentUpdateParams;
    export import ContentGetParams = ContentAPI.ContentGetParams;
    export import Settings = SettingsAPI.Settings;
    export import SettingEditParams = SettingsAPI.SettingEditParams;
    export import SettingGetParams = SettingsAPI.SettingGetParams;
    export import Deployments = DeploymentsAPI.Deployments;
    export import Deployment = DeploymentsAPI.Deployment;
    export import DeploymentCreateResponse = DeploymentsAPI.DeploymentCreateResponse;
    export import DeploymentGetResponse = DeploymentsAPI.DeploymentGetResponse;
    export import DeploymentCreateParams = DeploymentsAPI.DeploymentCreateParams;
    export import DeploymentGetParams = DeploymentsAPI.DeploymentGetParams;
    export import Versions = VersionsAPI.Versions;
    export import VersionCreateResponse = VersionsAPI.VersionCreateResponse;
    export import VersionListResponse = VersionsAPI.VersionListResponse;
    export import VersionGetResponse = VersionsAPI.VersionGetResponse;
    export import VersionListResponsesV4PagePagination = VersionsAPI.VersionListResponsesV4PagePagination;
    export import VersionCreateParams = VersionsAPI.VersionCreateParams;
    export import VersionListParams = VersionsAPI.VersionListParams;
    export import VersionGetParams = VersionsAPI.VersionGetParams;
}
//# sourceMappingURL=scripts.d.ts.map