import * as Core from "../../../core.js";
import { APIResource } from "../../../resource.js";
import * as GroupsAPI from "./groups.js";
import * as AccessAPI from "./access.js";
import { SinglePage } from "../../../pagination.js";
export declare class Groups extends APIResource {
    /**
     * Creates a new Access group.
     */
    create(params: GroupCreateParams, options?: Core.RequestOptions): Core.APIPromise<ZeroTrustGroup>;
    /**
     * Updates a configured Access group.
     */
    update(groupId: string, params: GroupUpdateParams, options?: Core.RequestOptions): Core.APIPromise<ZeroTrustGroup>;
    /**
     * Lists all Access groups.
     */
    list(params?: GroupListParams, options?: Core.RequestOptions): Core.PagePromise<ZeroTrustGroupsSinglePage, ZeroTrustGroup>;
    list(options?: Core.RequestOptions): Core.PagePromise<ZeroTrustGroupsSinglePage, ZeroTrustGroup>;
    /**
     * Deletes an Access group.
     */
    delete(groupId: string, params?: GroupDeleteParams, options?: Core.RequestOptions): Core.APIPromise<GroupDeleteResponse>;
    delete(groupId: string, options?: Core.RequestOptions): Core.APIPromise<GroupDeleteResponse>;
    /**
     * Fetches a single Access group.
     */
    get(groupId: string, params?: GroupGetParams, options?: Core.RequestOptions): Core.APIPromise<ZeroTrustGroup>;
    get(groupId: string, options?: Core.RequestOptions): Core.APIPromise<ZeroTrustGroup>;
}
export declare class ZeroTrustGroupsSinglePage extends SinglePage<ZeroTrustGroup> {
}
export interface ZeroTrustGroup {
    /**
     * UUID
     */
    id?: string;
    created_at?: string;
    /**
     * Rules evaluated with a NOT logical operator. To match a policy, a user cannot
     * meet any of the Exclude rules.
     */
    exclude?: Array<AccessAPI.AccessRule>;
    /**
     * Rules evaluated with an OR logical operator. A user needs to meet only one of
     * the Include rules.
     */
    include?: Array<AccessAPI.AccessRule>;
    /**
     * Rules evaluated with an AND logical operator. To match a policy, a user must
     * meet all of the Require rules.
     */
    is_default?: Array<AccessAPI.AccessRule>;
    /**
     * The name of the Access group.
     */
    name?: string;
    /**
     * Rules evaluated with an AND logical operator. To match a policy, a user must
     * meet all of the Require rules.
     */
    require?: Array<AccessAPI.AccessRule>;
    updated_at?: string;
}
export interface GroupDeleteResponse {
    /**
     * UUID
     */
    id?: string;
}
export interface GroupCreateParams {
    /**
     * Body param: Rules evaluated with an OR logical operator. A user needs to meet
     * only one of the Include rules.
     */
    include: Array<AccessAPI.AccessRuleParam>;
    /**
     * Body param: The name of the Access group.
     */
    name: string;
    /**
     * Path param: The Account ID to use for this endpoint. Mutually exclusive with the
     * Zone ID.
     */
    account_id?: string;
    /**
     * Path param: The Zone ID to use for this endpoint. Mutually exclusive with the
     * Account ID.
     */
    zone_id?: string;
    /**
     * Body param: Rules evaluated with a NOT logical operator. To match a policy, a
     * user cannot meet any of the Exclude rules.
     */
    exclude?: Array<AccessAPI.AccessRuleParam>;
    /**
     * Body param: Whether this is the default group
     */
    is_default?: boolean;
    /**
     * Body param: Rules evaluated with an AND logical operator. To match a policy, a
     * user must meet all of the Require rules.
     */
    require?: Array<AccessAPI.AccessRuleParam>;
}
export interface GroupUpdateParams {
    /**
     * Body param: Rules evaluated with an OR logical operator. A user needs to meet
     * only one of the Include rules.
     */
    include: Array<AccessAPI.AccessRuleParam>;
    /**
     * Body param: The name of the Access group.
     */
    name: string;
    /**
     * Path param: The Account ID to use for this endpoint. Mutually exclusive with the
     * Zone ID.
     */
    account_id?: string;
    /**
     * Path param: The Zone ID to use for this endpoint. Mutually exclusive with the
     * Account ID.
     */
    zone_id?: string;
    /**
     * Body param: Rules evaluated with a NOT logical operator. To match a policy, a
     * user cannot meet any of the Exclude rules.
     */
    exclude?: Array<AccessAPI.AccessRuleParam>;
    /**
     * Body param: Whether this is the default group
     */
    is_default?: boolean;
    /**
     * Body param: Rules evaluated with an AND logical operator. To match a policy, a
     * user must meet all of the Require rules.
     */
    require?: Array<AccessAPI.AccessRuleParam>;
}
export interface GroupListParams {
    /**
     * The Account ID to use for this endpoint. Mutually exclusive with the Zone ID.
     */
    account_id?: string;
    /**
     * The Zone ID to use for this endpoint. Mutually exclusive with the Account ID.
     */
    zone_id?: string;
}
export interface GroupDeleteParams {
    /**
     * The Account ID to use for this endpoint. Mutually exclusive with the Zone ID.
     */
    account_id?: string;
    /**
     * The Zone ID to use for this endpoint. Mutually exclusive with the Account ID.
     */
    zone_id?: string;
}
export interface GroupGetParams {
    /**
     * The Account ID to use for this endpoint. Mutually exclusive with the Zone ID.
     */
    account_id?: string;
    /**
     * The Zone ID to use for this endpoint. Mutually exclusive with the Account ID.
     */
    zone_id?: string;
}
export declare namespace Groups {
    export import ZeroTrustGroup = GroupsAPI.ZeroTrustGroup;
    export import GroupDeleteResponse = GroupsAPI.GroupDeleteResponse;
    export import ZeroTrustGroupsSinglePage = GroupsAPI.ZeroTrustGroupsSinglePage;
    export import GroupCreateParams = GroupsAPI.GroupCreateParams;
    export import GroupUpdateParams = GroupsAPI.GroupUpdateParams;
    export import GroupListParams = GroupsAPI.GroupListParams;
    export import GroupDeleteParams = GroupsAPI.GroupDeleteParams;
    export import GroupGetParams = GroupsAPI.GroupGetParams;
}
//# sourceMappingURL=groups.d.ts.map